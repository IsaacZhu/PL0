# ? 列表式赋值的实现

## ?.1 实现的功能

实现常量类型列表，形如："[[1, 2, a, b[1][3], c]]"，目前仅支持赋值操作。

**注**：
1. 列表元素仅能为数字常量、变量、数组（且数组下表为常量）。

2. 赋值的时候，请自行保证代码正确性（不检查长度与元素是否为左值）。

3. 无边框的列表赋值仍存在，且依旧支持所有的expression赋值（但不能连续赋值）

## ?.2 实现的原理

[[b[1][2], c, a]] := [[a, b[1][2], c]] := [[d, 1, 78]]

为下列代码序列的语法糖。

```pl0

a := d;
b[1][2] := 1;
c := 78;

b[1][2] := a;
c := b[1][2];
a := c;

``` 


## ?.3 实现的思路

维持一个赋值栈，将列表左值依次记录，然后从栈顶开始依次赋值。

## ?.4 具体实现

首先新的数据类型 list用单链表实现。

然后依次将 list 的地址存入赋值栈。

最后，用 stack[top-1] = stack[top]; --top; 的次序依次为列表赋值。

每个列表赋值的具体实现为，遍历右值链表，将每一个元素的值取出，并在左值链表找到相应的元素地址，将其存入。
直到链表遍历结束。

## ?.5 效果

```pl0

var  a, b, c, arr[4][6][8];
begin
    [[a, b, c]] := [[arr[1][2][3], b, a]] := [[b, a, c]] := [[14, 97, 33]];
    printf("a = @0, b = @1, c = @2, arr123 = @3\n", a, b, c, arr[1][2][3]);
end.

```

输出结果

```

Begin executing PL/0 program.
a = 14, b = 97, c = 14, arr123 = 14
End executing PL/0 program.

```

## ?.6 后续工作

此处新增了列表类型，但没有完全支持链表类型操作。后续工作考虑围绕这一新类型展开。