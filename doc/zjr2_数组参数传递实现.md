# 数组参数传递实现

朱嘉润 17.11.20

------

## 目录

### 1.实现的功能

### 2.实现思路

### 3.具体实现

### 4.更多工作

------

## 1.实现的功能

1. 支持整个数组作为参数被调用，如：

   ``` pascal
   var a[2][3][4],i;
   procedure p(a[2][3][4]);
   begin
   	return a[1][1][1];
   end;
   begin
   	i:=p(a);
   end.
   ```

2. 支持数组元素作为参数被调用，如：

   ``` pascal
   var a[2][3][4],i;
   procedure p(tmp);
   begin
   	return tmp;
   end;
   begin
   	i:=p(a[1][1][1]);
   end.
   ```

3. 依旧支持炫酷的作用域规则，同名变量以最近作用域为准，如:

   ``` pascal
   var a[2][3][4],b[2][3][4];
   procedure p(a[2][3][4])
   	procedure q(b[2][3][4])
   	begin
   	end;
   begin
   	q(a);	//此处a是b，则在q中，b是实际上的b
   	q(b);	//在q中，b是实际上的b
   end
   begin
   	p(b)	//在p中，a是实际上的b
   end.
   ```

   子过程中可以调用父过程中的数组（只要不与参数同名）。

------
##2.实现思路

1. 函数声明时的参数处理：在分析参数时，如果发现这是数组，将其记录下来，并将维度等信息记录下来，添加到该函数对应的符号表中，注明类型的参数数组（ID_PARRAY），这个数组添加过程可能有两种情况：

   （1）与已有的某个数组同名：覆盖该数组，修改其维度为参数数组的维度。

   （2）没有同名数组：在符号表中建立一个新数组，类型为ID_PARRAY

2. 子函数调用参数数组时的处理：根据要求，父函数会将数组首地址传进来，因此分析到数组类型是ID_PARRAY时，不再使用原有LEA指令获取数组首地址，而是使用LOD指令，将数组首地址取出，后面维度分析与普通数组相同。

3. 子函数将参数数组作为参数向下传递的处理：类似地，使用LOD指令，将参数数组地址取出后作为参数压栈即可。

4. 函数调用带数组参数的子函数时的处理，如：

   ```  pascal
   var i,a[1][1];
   procedure p(a[1][1]);
   begin
   	...
   end
   begin
   	i:=p(a);
   end.
   ```
   在i:=p(a);这句的分析处，首先会读取参数列表，得知该参数是数组后，将数组首地址和其他数组参数压栈。类似地，若该数组是参数数组，也将数组首地址和其他参数压栈。

------

## 3.具体实现

1. 子函数声明时的参数处理：     

   （1）pl0.h：修改tmpparam数组的定义，添加kind和value属性。实际上就是改成comtab     

   （2）pl0.c：修改所有用到tmpparam的地方，tmpparam[i]改成tmpparam[i].name     

   （3）pl0.c：block：分析参数时，区分类型，如果有[的，则类型设为ID_ARRAY，否则是ID_VARIABLE (#Z1)     （4）pl0.c：param_enter：复制符号表时，区分ID_VARIABLE和ID_ARRAY，前者对父函数中的同名变量作覆盖处理，后者不进行覆盖，完全保留同名数组信息，分两种情况：a.与父函数中某个数组同名：添加一项表项，类型为ID_PARRAY，表明是数组参数；b.无同名数组：在子函数符号表中创建一个新数组，在栈中显式地存储地址，深度，每一维的宽度(#Z2)     

   （5）pl0.c：添加函数old_position，这个是原来的position，能够正确处理参数传递时的取position值（#Z3）     

   （6）pl0.h：添加ID_PARRAY（#Z4）     

   （7）pl0.c：param_enter：将参数数组的类型设置成PARRAY（#Z17）

2. 子函数分析代码时遇到参数数组的处理：     

   （1）pl0.h：添加变量isarrayparam，初始化为0（#Z5）     

   （2）pl0.c：position：修复了position的一个bug：若第一个定义的是数组且对改数组寻址，会返回0（#Z7）     

   （3）pl0.c：factor：修改factor函数，有则说明是参数，不需要用LEA。此时先把地址LOD出来，然后利用该数组的名字从前面开始遍历，进行寻址，完成对数组作为右值的处理（#Z6）     

   （4）pl0.c：statement：修改statement函数，完成对数组作为左值的处理（#Z8）

3. 调用时的数组参数处理：     

   （1）pl0.h：修改stnode定义，加入参数列表的记录；添加error(31)：参数类型不匹配；添加error(33)：找不到该函数（#Z9）     

   （2）pl0.c：node_delete：作修改，分析完成的函数不需要离开链表，移交链表控制权即可（#Z10）     

   （3）pl0.c：node_insert：作修改，首先是加入链表变成尾插，插入func后面，然后是加入参数列表（#Z11）     

   （4）pl0.c：新增函数int *node_getplist(char *name)：在链表中寻找，获取该名字的参数列表，返回参数列表（kind数组）（#Z12）     

   （5）pl0.c：node_insert：添加将tmpparam复制到paralist，只需记录类型即可（#Z13）     

   （6）pl0.c：factor：在调用函数时调用node_getplist获取参数列表paralist，根据paralist分析参数类型，如果类型不匹配则报error；如果匹配到数组类型，先对数组参数一一比对，比对正确后将首地址压栈，否则报error（#Z14）     

   （7）pl0.c：position：修改使得能够在遇到PARRAY时执行跟ARRAY同样的动作（#Z15）     

   （8）pl0.c：nodeparam：修改使其能根据函数名匹配来返回值（#Z16）

------

## 4.更多工作

1. 添加更为复杂而稳健的参数类型匹配：对数组的类型及维度进行匹配，即一一比对维度个数和大小，若有误则报错。
2. 支持数组指针。

------

## 5.example
	ex7
