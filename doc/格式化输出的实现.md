# ? 格式化输出的实现

## ?.1 实现的功能

添加内置函数 printf，使之功能与 C stdio.h 中的printf 形态功能相似。

使用形似 printf("@0 = fact(@1)\n@0 is result\n", fact(a), a)

其中 @ 是功能符号，用来引用后面的值表，如果想打印 '@' 则需要使用转义符号 '\' 。

转义符支持情况与 C 类似，现支持：

\@, \a, \b, \n, \r, \t, \\, \' 以及 \"

printf 第一个参数一定是字符串格式，后面是不定长参数表，里边可以是表达式（变量、有值函数等），在前面的格式中后面的值可重复引用，比如写若干个 @3 引用的值都是第四个（从 0 计数）。

注意事项：

最多支持 32 条 printf 语句，每个格式字符串不超过128个字符（\t算两个字符）。

## ?.2 实现的原理

在 pl0 的解释器中添加字符输出指令 OUTS，在遇到内置函数 printf 时处理并产生 OUTS 的指令。

## ?.3 实现的思路

格式化输出有三个部分，格式，字符以及值。

格式则需要在 getsym 中添加对 SYM_FORMAT 的识别，它的格式是以两个非转义引号包裹的字符串。其中转义符会被转义，字符值原样存储，对值的引用将会按引用位置特殊标记。

输出的时候，先将引用的值表各个求值压入栈顶。等到按格式输出时，遇到引用值则查找距离栈顶的若干偏移量的值。

输出结束后，将输出值表从栈顶弹出。

## ?.4 具体实现

在 getsym 时，维持一个临时栈。将字符串原样存储。

等到处理这个 SYM_FORMAT 时，调用 formatTransfer 函数，将这个字符串处理为格式，存入 pl0 系统的某个输出栈中。

处理后面的被引用的值，则当做 expression 处理。这样他们会将自己的结果按顺序压入栈。

最后是产生一条 OUTS 指令，用 i.l 共有多少引用值，用 i.a 指示是哪个输出栈。

运行时，OUTS 将输出栈的符号按序输出，如遇引用值，则从栈中找到那个值并打印。

运行结束后，将栈顶减去 i.l，维护栈的卫生。

## ?.5 效果

```pl0

var result, a, b, c;
procedure fact(n);
begin
	if n<2 then return 1;
	else return fact(-1+n)*n;
end;
begin
    a := 2;
    b := 999;
    printf("hello @0\t\t\t@1\n@0\"@2\n", a, b, fact(5));
    printf("@0\n", fact(3));
    printf("@0\n", fact(2));
    result := a + b;
    printf("@0\t@1\t@0\n", random(), random());
end.

```

输出结果

```

Begin executing PL/0 program.
hello 2                 999
2"120
6
2
288604566       1244251088      288604566
End executing PL/0 program.

```

## ?.6 后续工作

无